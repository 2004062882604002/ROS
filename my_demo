#include <ros/ros.h>
#include <sensor_msgs/PointCloud2.h>
#include <nav_msgs/OccupancyGrid.h>
#include <rosbag/bag.h>
#include <rosbag/view.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl/point_cloud.h>
#include <pcl/point_types.h>
#include <pcl/registration/icp.h>
#include <pcl/filters/voxel_grid.h>

using namespace std;

class GridMappingNode
{
public:
  GridMappingNode()
  {
    // 初始化ROS节点
    ros::NodeHandle nh;

    // 创建地图发布器
    map_pub_ = nh.advertise<nav_msgs::OccupancyGrid>("/grid_map", 1);
  }

  void generateGridMap(const sensor_msgs::PointCloud2::ConstPtr& pointcloud_msg)
  {
    // 将点云数据转换为PCL格式
    pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::fromROSMsg(*pointcloud_msg, *pcl_cloud);

    // 进行点云滤波，降低点云的密度
    pcl::PointCloud<pcl::PointXYZ>::Ptr filtered_cloud(new pcl::PointCloud<pcl::PointXYZ>);
    pcl::VoxelGrid<pcl::PointXYZ> voxel_grid;
    voxel_grid.setInputCloud(pcl_cloud);
    voxel_grid.setLeafSize(0.1, 0.1, 0.1);  // 设置体素大小
    voxel_grid.filter(*filtered_cloud);

    // 进行点云配准，得到栅格地图
    // 这里使用ICP算法进行配准，你可以根据实际需求选择其他算法
    pcl::IterativeClosestPoint<pcl::PointXYZ, pcl::PointXYZ> icp;
    icp.setInputSource(filtered_cloud);
    icp.setInputTarget(filtered_cloud);  // 设置目标点云数据
    icp.setMaximumIterations(100);
    icp.align(*filtered_cloud);

    // 创建栅格地图对象
    nav_msgs::OccupancyGrid map_msg;

    // 设置栅格地图的尺寸和分辨率
    map_msg.info.width = 100;  // 栅格地图的宽度（以栅格为单位）
    map_msg.info.height = 100;  // 栅格地图的高度（以栅格为单位）
    map_msg.info.resolution = 0.1;  // 栅格地图的分辨率

    // 将栅格地图的原点设置为点云的中心
    map_msg.info.origin.position.x = filtered_cloud->points[0].x - map_msg.info.width * map_msg.info.resolution / 2.0;
    map_msg.info.origin.position.y = filtered_cloud->points[0].y - map_msg.info.height * map_msg.info.resolution / 2.0;
    map_msg.info.origin.orientation.w = 1.0;

    // 将点云中的每个点映射到栅格地图上
    for (const auto& point : filtered_cloud->points)
    {
      int map_x = (point.x - map_msg.info.origin.position.x) / map_msg.info.resolution;
      int map_y = (point.y - map_msg.info.origin.position.y) / map_msg.info.resolution;

      // 检查栅格坐标是否在地图范围内
      if (map_x >= 0 && map_x < map_msg.info.width && map_y >= 0 && map_y < map_msg.info.height)
      {
        int index = map_y * map_msg.info.width + map_x;
        map_msg.data[index] = 100;  // 设置栅格的值为100表示有障碍物
      }
    }

    // 发布栅格地图
    map_pub_.publish(map_msg);
  }

  void processBagFile(const string& bag_file)
  {
    rosbag::Bag bag;
    bag.open(bag_file, rosbag::bagmode::Read);

    vector<string> topics;
    topics.push_back("/rslidar_points");  // 替换为实际的点云数据话题

    rosbag::View view(bag, rosbag::TopicQuery(topics));

    for (const rosbag::MessageInstance& msg : view)
    {
      sensor_msgs::PointCloud2::ConstPtr pointcloud_msg = msg.instantiate<sensor_msgs::PointCloud2>();
      if (pointcloud_msg != nullptr)
      {
        generateGridMap(pointcloud_msg);
      }
    }

    bag.close();
  }

private:
  ros::Publisher map_pub_;
};

int main(int argc, char** argv)
{
  // 初始化ROS节点
  ros::init(argc, argv, "grid_mapping_node");

  // 创建GridMappingNode对象
  GridMappingNode grid_mapping_node;

  // 设置bag文件路径
  string bag_file = "/home/zlx/all.bag";

  // 处理ROSbag文件
  grid_mapping_node.processBagFile(bag_file);

  return 0;
}
